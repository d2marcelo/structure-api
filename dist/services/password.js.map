{"version":3,"sources":["../../src/services/password.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;;;;AACA;;;;IAEM,e;AAEJ,6BAA0B;AAAA,QAAd,OAAc,yDAAJ,EAAI;AAAA;;AACxB,SAAK,OAAL,GAAe,OAAf;AACD;;;;0BAEK,C,EAAG;AAAA;;AAEP,aAAO,sBAAa,UAAC,OAAD,EAAU,MAAV,EAAqB;;AAEvC,YAAG,OAAO,CAAP,IAAY,QAAf,EAAyB,OAAO,GAAG;AACjC,mBAAS,2BADwB;AAEjC,oBAAU;AAFuB,SAAH,CAAP;;AAKzB,yBAAO,OAAP,CACE,SAAS,MAAK,OAAL,CAAa,OAAtB,KACA,SAAS,QAAQ,GAAR,CAAY,WAArB,CADA,IAEA,EAHF,EAIA,SAAS,+BAAT,CAAyC,GAAzC,EAA8C,IAA9C,EAAoD;AAClD,cAAG,GAAH,EAAQ;AACN,2BAAO,KAAP,CAAa,yBAAb,EAAwC,GAAxC;AACA,mBAAO,OAAO,GAAP,CAAP;AACD;;AAED,2BAAO,IAAP,CAAY,CAAZ,EAAe,IAAf,EAAqB,SAAS,4BAAT,CAAsC,GAAtC,EAA2C,IAA3C,EAAiD;AACpE,gBAAG,GAAH,EAAQ;AACN,6BAAO,KAAP,CAAa,yBAAb,EAAwC,GAAxC;AACA,qBAAO,OAAO,GAAP,CAAP;AACD;;AAED,oBAAQ,IAAR;AACD,WAPD;AASD,SAnBD;AAqBD,OA5BM,CAAP;AA8BD;;;2BAEM,C,EAAG,I,EAAM;;AAEd,aAAO,sBAAa,UAAC,OAAD,EAAU,MAAV,EAAqB;;AAEvC,yBAAO,OAAP,CAAe,CAAf,EAAkB,IAAlB,EAAwB,SAAS,+BAAT,CAAyC,GAAzC,EAA8C,KAA9C,EAAqD;;AAE3E,cAAG,GAAH,EAAQ;AACN,2BAAO,KAAP,CAAa,2BAAb,EAA0C,GAA1C;AACA,2BAAO,KAAP,CAAa,UAAb,EAAyB,CAAzB;AACA,2BAAO,KAAP,CAAa,MAAb,EAAqB,IAArB;AACA,mBAAO,OAAO,GAAP,CAAP;AACD;;AAED,iBAAO,QAAQ,IAAR,CAAP;AAED,SAXD;AAaD,OAfM,CAAP;AAiBD;;;;;kBAIY,e","file":"password.js","sourcesContent":["import bcrypt          from 'bcrypt'\nimport {chalk, logger} from '../lib/logger'\n\nclass PasswordService {\n\n  constructor(options = {}) {\n    this.options = options\n  }\n\n  issue(s) {\n\n    return new Promise( (resolve, reject) => {\n\n      if(typeof s != 'string') return cb({\n        message: 'Password must be a string',\n        resource: 'PasswordService'\n      })\n\n      bcrypt.genSalt(\n        parseInt(this.options.genSalt) ||\n        parseInt(process.env.SALT_FACTOR) ||\n        10,\n      function PasswordService_genSaltCallback(err, salt) {\n        if(err) {\n          logger.error('Could not generate salt', err)\n          return reject(err)\n        }\n\n        bcrypt.hash(s, salt, function PasswordService_hashCallback(err, hash) {\n          if(err) {\n            logger.error('Could not generate hash', err)\n            return reject(err)\n          }\n\n          resolve(hash)\n        })\n\n      })\n\n    })\n\n  }\n\n  verify(s, hash) {\n\n    return new Promise( (resolve, reject) => {\n\n      bcrypt.compare(s, hash, function PasswordService_compareCallback(err, match) {\n\n        if(err) {\n          logger.error('Could not verify password', err)\n          logger.debug('Password', s)\n          logger.debug('Hash', hash)\n          return reject(err)\n        }\n\n        return resolve(true)\n\n      })\n\n    })\n\n  }\n\n}\n\nexport default PasswordService\n"]}